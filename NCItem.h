/*
NCItem: A nonclustered item. Wraps a regular item pointer* and implements the same getters, but has no fields.
    *The pointer will be the primary key. This is because we can't rely on things to be in the same place in memory when the tree is reconstituted.

The goal of this class is to allow for operations on secondary keys and combinations of keys.

This will be achieved by having multiple B+ trees for different non-primary keys and non-primary key combinations.

This class will wrap a pointer to a physical item in the primary B+ tree (the one sorted by the integer primary key).

It will implement all the same methods of the regular item class by referencing the physical record, 
allowing for all the same types of comparisons without wasting more space on copies of key fields.

Different comparator methods will be provided for different keys and combinations of keys.

The B+ tree nodes' insert methods will be refactored to take as a parameter an instruction
telling it which comparator to use for B+ tree operations.

Those methods rely on returning null to tell their parents when they haven't split, so that approach has to be preserved.
They will be refactored to return a wrapping class that holds a BPNode pointer and an item pointer. 
    The first slot in the array will serve the same purpose of the original return value.
    The second slot will be a pointer to the item that was just inserted.
        After insertion into the primary B+ tree, the returned item pointer will be wrapped in this class and inserted into the secondary clustered indexes.
*/

#include <iostream>
#include "ItemInterface.h"
#include "BPlusTree.h"

using namespace std;

template<typename T> class BPlusTree;

class NCItem : ItemInterface {
    private:
        vector<int> pointerKeys; // points to the physical record in the clustered index
        BPlusTree<int>* clusteredIndex; // pointer to the clustered index

    public:
                NCItem(int pointer, BPlusTree<int>* mainTree) : pointerKeys(pointer), clusteredIndex(mainTree) {}

                void addDupeKey(int newDupe)
                {
                    pointerKeys.push_back(newDupe); // this is safe because primary keys will be generated by incrementing up.
                }

                vector<int> getPrimaryKeys() {
                    return this->pointerKeys;
                }

                AttributeType getKeyByIndex(int index) {
                    // search main tree for item (concrete item)
                    // call this same method on that item
                    // return result
                }

                void setAttributeByIndex(int index, AttributeType attr) {
                    // search main tree for real item
                    // call this method on the real item
                    // and of course, write to disk.
                    // maybe cout a confirmation
                }

                size_t size() {
                    // search the main tree for the real item. return the result of calling size on that. also fix the size method TODO
                }
                
                /*
                this < that: return -1
                this == that: return 0
                this > that: return 1
                */
                int comparePrimary(ItemInterface* that) = 0;
                int compareByIndex(ItemInterface* that, int index) = 0;
                int dynamicCompare(ItemInterface* that, int index) = 0;
                
                int comparePrimaryToKey(const any& thatPK) = 0;
                
                int compareToKeyByIndex(const any& thatPK, int index) = 0;
                
                int dynamicCompareToKey(const any& thatPK, int index) = 0;
};
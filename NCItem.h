/*
NCItem: A nonclustered item. Wraps a regular item pointer* and implements the same getters, but has no fields.
    *The pointer will be the primary key. This is because we can't rely on things to be in the same place in memory when the tree is reconstituted.

The goal of this class is to allow for operations on secondary keys and combinations of keys.

This will be achieved by having multiple B+ trees for different non-primary keys and non-primary key combinations.

This class will wrap a pointer to a physical item in the primary B+ tree (the one sorted by the integer primary key).

It will implement all the same methods of the regular item class by referencing the physical record, 
allowing for all the same types of comparisons without wasting more space on copies of key fields.

Different comparator methods will be provided for different keys and combinations of keys.

The B+ tree nodes' insert methods will be refactored to take as a parameter an instruction
telling it which comparator to use for B+ tree operations.

Those methods rely on returning null to tell their parents when they haven't split, so that approach has to be preserved.
They will be refactored to return a wrapping class that holds a BPNode pointer and an item pointer. 
    The first slot in the array will serve the same purpose of the original return value.
    The second slot will be a pointer to the item that was just inserted.
        After insertion into the primary B+ tree, the returned item pointer will be wrapped in this class and inserted into the secondary clustered indexes.
*/

#include <cstddef>
#include <iostream>
#include "ItemInterface.h"
#include "BPlusTree.h"

using namespace std;

template<typename T> class BPlusTreeBase;

class NCItem : public ItemInterface {
    private:
        vector<int> pointerKeys; // points to the physical record in the clustered index
        std::shared_ptr<BPlusTreeBase<int>> clusteredIndex; // pointer to the clustered index
    
    public:
        ~NCItem() {};
    
        NCItem(int pointer, std::shared_ptr<BPlusTreeBase<int>> mainTree) {
            pointerKeys.push_back(pointer);
            clusteredIndex = std::move(mainTree);
        }
    
        bool isClustered() {
            return false;
        }
    
    
        // Search for all PKs in main tree and concat them all.
        vector<ItemInterface*> singleKeySearchResult() {
            vector<ItemInterface*> result;
            for (int PK : pointerKeys) {
                result.push_back(clusteredIndex->singleKeySearch(PK));
            }
            return result;
        }


        void addDupeKey(int newDupe)
        {
            pointerKeys.push_back(newDupe); // this is safe because primary keys will be generated by incrementing up.
        }

        // gets the FIRST PK
        int getPrimaryKey() {
            return this->pointerKeys[0];
        }

        AttributeType getKeyByIndex(int index) {
            ItemInterface* find = clusteredIndex->singleKeySearch(index);
            return find->getKeyByIndex(index);
        }

        void setAttributeByIndex(int index, AttributeType attr) {
            // search main tree for real item
            // call this method on the real item
            // and of course, write to disk.
            // maybe cout a confirmation
            ItemInterface* find = clusteredIndex->singleKeySearch(index);
            find->setAttributeByIndex(index, attr);
        }

        size_t size() {
            size_t x = sizeof(NCItem);
            // cout << "NCItem size: " << x << endl;
            return x;
        }

        /*
        ALL THE FOLLOWING METHODS SEARCH FOR THE FIRST INSTANCE OF THE THING IN THE MAIN TREE (pointerKeys[0])
        
        this < that: return -1
        this == that: return 0
        this > that: return 1
        */
        const any dynamicGetKeyByIndex(int index) {
            ItemInterface* find = clusteredIndex->singleKeySearch(pointerKeys[0]);
            return find->dynamicGetKeyByIndex(index);
        }

        int comparePrimary(ItemInterface* that) {
            ItemInterface* find = clusteredIndex->singleKeySearch(pointerKeys[0]);
            return find->comparePrimary(that);
        }

        int compareByIndex(ItemInterface* that, int index) {
            ItemInterface* find = clusteredIndex->singleKeySearch(pointerKeys[0]);
            return find->compareByIndex(that, index);
        }

        int dynamicCompare(ItemInterface* that, int index) {
            ItemInterface* find = clusteredIndex->singleKeySearch(pointerKeys[0]);
            return find->dynamicCompare(that, index);
        }
        
        int comparePrimaryToKey(const any& thatPK) {
            ItemInterface* find = clusteredIndex->singleKeySearch(pointerKeys[0]);
            return find->comparePrimaryToKey(thatPK);
        }
        
        int compareToKeyByIndex(const any& thatK, int index) {
            ItemInterface* find = clusteredIndex->singleKeySearch(pointerKeys[0]);
            return find->compareToKeyByIndex(thatK, index);
        }
        
        int dynamicCompareToKey(const any& thatPK, int index) {
            ItemInterface* find = clusteredIndex->singleKeySearch(pointerKeys[0]);
            return find->dynamicCompareToKey(thatPK, index);
        }



        void removeAll() {
            for (int key : pointerKeys)
            {
                clusteredIndex->remove(key);
            }
        }



        // PRINT ALL ITEMS IN THE CLUSTERED INDEX WITH OUR KEY
        void print () {
            vector<ItemInterface*> result = singleKeySearchResult();
            for (ItemInterface* item : result)
            {
                item->print();
            }
        }
};